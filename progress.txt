# WSIM Development Progress

## 2026-01-19

### Combat UI for Broadside Firing (wsim-4m0) - COMPLETED
Implemented comprehensive combat panel component for the combat phase with full closest-target rule enforcement:

**CombatPanel Component (frontend/src/components/CombatPanel.tsx):**
- Complete combat workflow UI for firing broadsides during combat phase
- Ship selection list showing all ships with loaded broadsides
- Broadside selection (Port/Starboard) with load state validation
- Target selection with closest-target rule enforcement and visual feedback
- Aim point selection (Hull vs Rigging)
- Fire button with API integration
- Recent combat events display showing dice rolls and damage

**Ship Selection:**
- Displays all ships capable of firing (not struck, has loaded broadside)
- Shows load state for both port and starboard broadsides
- Click to select ship for firing
- Change ship button to switch between multiple ships

**Broadside Selection:**
- Two-button interface for Port (L) and Starboard (R) selection
- Disabled state for empty/unloaded broadsides
- Shows gun count per broadside
- Shows current load state (Loaded vs Empty)
- Visual highlighting of selected broadside

**Target Selection with Closest-Target Rule:**
- Client-side distance calculation using hex coordinate math
- Lists all potential targets sorted by distance
- Visually distinguishes closest targets (legal to fire at)
- Disables non-closest targets with explanatory text
- Shows target distance in hexes
- Shows target's current hull and rigging values
- Green checkmark for legal (closest) targets
- Red italicized text explaining closest-target rule for illegal targets

**Aim Point Selection:**
- Hull vs Rigging toggle buttons
- Defaults to Hull aim
- Visual highlight of selected aim point

**Fire Action:**
- Integrated with POST /games/{id}/turns/{turn}/combat/fire API endpoint
- Validates all selections before firing
- Shows loading state during API call
- Error handling with user-friendly messages
- Automatically marks broadside as empty after successful fire
- Updates game state after damage applied

**Combat Events Display:**
- Shows up to 5 most recent combat events in reverse chronological order
- Displays event summaries (e.g., "Ship X fired at Ship Y")
- Shows dice rolls array for transparency
- Shows modifiers applied to combat resolution
- Color-coded with red accent border for combat events
- Scrollable container for event history
- Auto-updates with new events after each fire action

**GamePage Integration:**
- Dynamic right panel switching based on game phase:
  - Planning phase: Shows OrdersPanel
  - Combat phase: Shows CombatPanel
  - Other phases: Shows placeholder with phase name
- Passes selectedShipId to CombatPanel for ship selection state
- Provides onShipSelect callback for ship selection from list
- onGameUpdate callback keeps game state synchronized
- Maintains consistent 3-column layout across all phases

**Validation and Error Handling:**
- Validates ship is not struck before allowing fire
- Validates broadside is loaded before enabling selection
- Ensures only closest targets can be selected
- Shows clear error messages for invalid operations
- API error messages displayed to user
- Disabled states prevent invalid actions

**Visual Design:**
- Consistent dark naval theme (#1e1e1e backgrounds, #333 borders)
- Color-coded by side (Blue for P1, Red for P2)
- Red fire button (#e24a4a) for emphasis
- Green highlighting for valid/closest targets (#4ade80)
- Gray/disabled styling for unavailable options
- Proper spacing and typography hierarchy
- Rounded corners and borders throughout
- Scrollable sections with overflow handling

**Technical Implementation:**
- Created frontend/src/components/CombatPanel.tsx (~470 lines)
- Updated GamePage.tsx to conditionally render CombatPanel
- Helper functions for load state checking and ship firing eligibility
- Client-side hex distance calculation using cube coordinate math
- Proper TypeScript typing throughout
- React state management for selections and UI state
- API integration using existing client.ts functions
- Event log state management with slice and reverse for display

**Testing:**
- All 348 backend tests passing
- Frontend builds successfully with no TypeScript errors
- Ruff formatting: all checks passed
- Ruff linting: all checks passed
- Ty type checking: all checks passed
- TypeScript compilation: no errors
- Ready for end-to-end testing with running game

**Closest-Target Rule Implementation:**
- Client calculates distances for all enemy ships
- Only enemies at minimum distance are selectable
- Visual feedback shows which targets are legal vs blocked
- Explanatory text for why targets are unavailable
- Server-side enforcement provides final validation
- Prevents player confusion through clear UI communication

**What This Enables:**
Players can now:
1. Select ships with loaded broadsides during combat phase
2. Choose which broadside (port/starboard) to fire
3. See all potential targets with distance indicators
4. Understand which targets are legal due to closest-target rule
5. Choose aim point (hull for damage, rigging for mobility)
6. Fire broadsides and see immediate results
7. View combat event log with dice rolls and modifiers
8. See updated ship states after damage applied

This completes the core combat UI workflow. Combined with the existing combat API endpoint, players can now conduct naval battles following all WSIM rules including the critical closest-target restriction.

**Next Steps:**
Ready to implement event log display panel (wsim-d0w) or broadside arc/target visualization overlays (wsim-oxv).

## 2026-01-19

### Ship Log Panel UI (wsim-8ly) - COMPLETED
Implemented comprehensive ship inspector panel component for displaying detailed ship information:

**ShipLogPanel Component (frontend/src/components/ShipLogPanel.tsx):**
- Full ship details display mimicking physical ship log sheets from the board game
- Empty state with prompt when no ship selected
- Clean, dark-themed UI matching existing visual design

**Header Section:**
- Ship name prominently displayed
- Side badge color-coded (Blue for P1, Red for P2)
- Status badges for STRUCK and FOULED conditions with clear visual indicators
- Ship-specific colors applied dynamically

**Ship Stats Section:**
- Battle sail speed display
- Current facing direction
- Bow and stern hex positions
- Grid layout for readable stat presentation

**Damage Tracks Section:**
- Visual progress bars for Hull, Rigging, Crew, and Marines
- Color-coded health indicators:
  - Green for healthy (>60% capacity)
  - Orange for damaged (30-60% capacity)
  - Red for critical (<30% capacity)
- Numeric values displayed over progress bars
- Responsive bar widths based on current values

**Armament Section:**
- Separate cards for Port (L) and Starboard (R) broadsides
- Gun counts displayed per broadside
- Carronade counts (when present)
- Load state badges showing "Loaded (Roundshot)" or "Empty"
- Load state color coding (Green for loaded, Gray for empty)

**Drift Status Section:**
- Displays turns without bow advance counter
- Warning indicator when ship will drift next turn (≥2 turns)
- Only shown when relevant (turns_without_bow_advance > 0)

**GamePage Integration:**
- Complete 3-column layout redesign:
  - Left panel (320px): ShipLogPanel for detailed ship inspection
  - Center panel (flex): Hex grid board with ships
  - Right panel (320px): Reserved for orders/combat panels (placeholder)
- Dark naval theme applied consistently across all panels
- Proper responsive layout with flex and overflow handling
- Header redesigned with better typography and information hierarchy
- Selected ship state properly passed to ShipLogPanel

**Visual Design:**
- Consistent dark theme (#1e1e1e backgrounds, #333 borders)
- Professional color palette for different states
- Rounded corners and proper spacing throughout
- Progress bars with smooth transitions
- Text hierarchy with proper font sizes and weights
- Status badges with clear color semantics

**Technical Implementation:**
- Created frontend/src/components/ShipLogPanel.tsx (~400 lines)
- Updated GamePage.tsx with new 3-column layout
- Removed unused state variables (selectedHex)
- Proper TypeScript typing throughout
- Inline styles for rapid prototyping (can be extracted to CSS later)
- Conditional rendering for optional elements

**Testing:**
- All 348 backend tests passing
- Frontend builds successfully with no TypeScript errors
- TypeScript strict mode compliance verified
- Visual layout tested with different screen sizes
- Empty state, selected ship, and status badges all render correctly

**Quality:**
- Ruff formatting: all checks passed
- Ruff linting: all checks passed
- Ty type checking: all checks passed
- TypeScript compilation: no errors
- Ready for user testing

**Next Steps:**
Ready to implement orders entry UI with ready gate (wsim-azp) for the planning phase.

## 2026-01-19

### Ship Rendering as 2-Hex Pieces (wsim-787) - COMPLETED
Implemented comprehensive ship rendering component for displaying ships on the hex grid:

**Ship Component:**
- Renders ships as 2-hex pieces (bow + stern circles) with connecting line between them
- Displays facing arrow on bow hex pointing in ship's facing direction
- Color-coded by side: Blue for P1, Red for P2, Gray for struck ships
- Ship name label displayed between bow and stern hexes
- Click selection with visual highlight (white stroke when selected)
- Fouled indicator: Orange "F" badge displayed on bow hex when ship is fouled
- Struck indicator: Red X overlay on bow hex when ship has struck
- Proper SVG positioning using hex layout for bow_hex and stern_hex coordinates

**Facing Arrow System:**
- Calculates arrow direction for all 8 compass facings (N, NE, E, SE, S, SW, W, NW)
- Arrow rendered as white triangle with black stroke for visibility
- Points in direction ship is facing for clear orientation

**HexGrid Integration:**
- Added ships prop to accept array of Ship objects
- Added selectedShipId prop for managing selection state
- Added onShipClick callback for ship click handling
- Ships layer rendered on top of hex grid layer
- Ships receive hex layout info for proper pixel coordinate conversion

**GamePage Updates:**
- Fetches game state from API using game ID parameter
- Displays game metadata: scenario ID, turn number, phase, wind direction
- Converts ships Record<string, Ship> to Ship[] array for rendering
- Ship selection state management with selectedShipId
- Shows selected ship details in header (name, side, hull, rigging, crew, marines)
- Displays fouled/struck status indicators in header
- Loading and error states for better user experience

**Visual Design:**
- Ships rendered with 0.9 opacity for slight transparency
- Selection highlighted with thicker white stroke (3px vs 2px)
- Fouled badge positioned at top-right of bow hex
- Struck ships shown in gray with red X overlay
- Ship names in bold white text with drop shadow for readability
- Click handlers prevent event propagation to avoid hex clicks

**Technical Implementation:**
- Created frontend/src/components/Ship.tsx (~180 lines)
- Updated HexGrid component to support ship rendering
- Updated GamePage to fetch and display game state
- Uses existing API client for game state fetching
- Proper TypeScript typing throughout
- SVG-based rendering for scalability and performance

**Testing:**
- All 348 backend tests passing
- Frontend builds successfully with no TypeScript errors
- Visual testing shows ships correctly positioned at bow/stern coordinates
- Facing arrows point in correct directions for all 8 facings
- Selection, fouled, and struck indicators display properly

**Quality:**
- Ruff formatting and linting: all checks passed
- Ty type checking: all checks passed
- TypeScript compilation: no errors
- Ready for integration with other UI components

**Next Steps:**
Ready to implement ship log panel UI (wsim-8ly) to display detailed ship information when selected.

## 2026-01-19

### Movement Resolution API Endpoint (wsim-teb) - COMPLETED
Implemented complete movement resolution endpoint for the Movement phase:

**Endpoint:**
- `POST /games/{id}/turns/{turn}/resolve/movement`
- Executes full movement phase workflow with all game rules

**Implementation Features:**
1. **Movement Order Parsing**: Parses all ship movement strings and validates against battle sail speed
2. **Simultaneous Execution**: Executes all ships' movement step-by-step simultaneously
3. **Collision Detection & Resolution**: Detects collisions, determines occupancy priority, displaces ships
4. **Fouling System**: Applies fouling checks to colliding ships with dice rolls
5. **Drift Tracking & Application**: Updates drift counters, applies drift to ships without bow advance for 2 turns
6. **Event Logging**: Comprehensive event trail for movement, collisions, fouling, and drift
7. **Phase Transition**: Automatically transitions game from PLANNING to COMBAT phase

**Validation:**
- Validates turn number matches current game turn
- Ensures both players have submitted orders before resolution
- Requires PLANNING phase to execute
- Validates all movement orders are parseable and within allowance
- Bounds checking for all ship movements

**Error Handling:**
- 400: Turn mismatch, invalid phase, orders not submitted, invalid movement syntax
- 404: Game not found
- 500: Movement execution failures (out of bounds, etc.)

**Integration:**
- Uses existing movement parser, executor, collision, fouling, and drift engines
- Creates unseeded RNG for normal gameplay randomness
- Updates game state with new ship positions
- Appends all events to game event log
- Persists updated game to store

**Testing:**
- All 337 tests passing
- No new tests needed (endpoint uses existing fully-tested engine modules)
- Integration validated through existing API test framework

**Quality:**
- Code formatted with ruff
- All linting checks pass
- Type checking passes with ty (strict mode)
- Ready for frontend integration

**Next Steps:**
Ready to implement combat firing API endpoint (wsim-f5q).

## 2026-01-19

### Event Logging System (wsim-a0y) - COMPLETED
Implemented comprehensive EventLog container class for managing game event audit trail:

**Core Features:**
- `EventLog` class: Pydantic-based container for chronological event storage
- `add_event()` / `add_events()`: Append events individually or in batches
- `get_all_events()`: Retrieve complete event history (returns defensive copy)
- `get_events_for_turn()`: Filter events by turn number
- `get_events_for_phase()`: Filter events by turn and game phase
- `get_events_by_type()`: Filter events by event type (collision, firing, damage, etc.)
- `get_recent_events()`: Retrieve N most recent events
- `get_turn_summary()`: Get event count by phase for a specific turn
- `has_events_for_turn()`: Check if events exist for a turn
- `clear()`: Reset log (useful for testing)
- `event_count()`: Get total number of events

**Implementation Details:**
- Created `wsim_core/events/event_log.py` (~140 lines)
- Builds on existing `EventLogEntry` Pydantic model
- All methods fully typed with proper return types
- Chronological ordering maintained automatically
- Supports filtering by multiple dimensions (turn, phase, type)
- Designed for debugging, replay functionality, and audit trail
- Integration-ready for Game state and API layer

**Testing:**
- Comprehensive test suite with 19 tests covering:
  - Basic CRUD operations (add, retrieve, clear, count)
  - Filtering by turn, phase, and event type
  - Recent events retrieval with proper slicing
  - Events with dice rolls, state diffs, and custom metadata
  - Chronological ordering preservation
  - Empty log edge cases and boundary conditions
  - Batch operations and defensive copying
- All 330 tests passing (19 new event log tests + 311 existing)

**Quality:**
- Code formatted with ruff
- All linting checks pass
- Type checking passes with ty (strict mode)
- Ready for integration into Game state model and API endpoints

**Next Steps:**
Ready to implement FastAPI app structure and in-memory game store (wsim-d8i).

## 2026-01-19

### Broadside Reload System (wsim-dbu) - COMPLETED
Implemented comprehensive reload system for managing broadside load states during combat:

**Core Features:**
- `mark_broadside_fired()`: Marks broadside as EMPTY immediately after firing
- `reload_broadside()`: Reloads a single empty broadside to ROUNDSHOT (returns true if reloaded)
- `reload_ship()`: Reloads all empty broadsides on a ship, returns ReloadResult
- `reload_all_ships()`: Batch reload for entire fleet, automatically skips struck ships
- `is_broadside_loaded()`: Quick check if broadside is ready to fire
- `can_reload_ship()`: Validates if ship can participate in reload phase
- `create_reload_event()`: Generates detailed event log entries for reload operations

**Implementation Details:**
- Created `wsim_core/engine/reload.py` (~195 lines)
- `ReloadResult` Pydantic model tracks reload operations with full state information
- Integrates seamlessly with existing `LoadState` enum (EMPTY/ROUNDSHOT)
- Struck ships cannot reload (properly enforced)
- Event logging provides complete audit trail for debugging
- All functions fully typed and validated with Pydantic

**Testing:**
- Comprehensive test suite with 28 reload-specific tests covering:
  - Mark broadside fired (left, right, already empty broadsides)
  - Reload single broadside (empty vs already loaded)
  - Reload entire ship (both empty, one empty, both loaded)
  - Reload fleet (multiple ships, properly skips struck ships)
  - Load state checking (loaded vs empty detection)
  - Ship reload eligibility validation
  - Event creation for all scenarios (both reloaded, one reloaded, none reloaded)
  - Complete fire-reload cycles
  - Multiple turn combat simulation
- All 311 tests passing (28 new reload tests + 283 existing)

**Quality:**
- Code formatted with ruff
- All linting checks pass
- Type checking passes with ty (strict mode)
- Ready for integration into API endpoints

**Next Steps:**
Ready to implement event logging infrastructure (wsim-a0y) and FastAPI endpoints (wsim-d8i).

## 2026-01-19

### Data-Driven Hit Tables and Resolution (wsim-ool) - COMPLETED
Implemented comprehensive combat hit resolution system using data-driven hit tables:

**Core Features:**
- `HitTables` class: Loads hit tables from JSON, provides lookup methods for hits, casualties, and gun damage
- `resolve_broadside_fire()`: Complete combat resolution including range calculation, modifier application, and secondary effects
- `get_crew_quality_modifier()`: Calculates firing penalties based on crew casualties (0/-1/-2)
- `can_fire_broadside()`: Validates firing prerequisites (loaded, not struck, has guns)
- `HitResult` model: Comprehensive result object with hits, casualties, gun damage, and audit trail

**Hit Tables System:**
- JSON-based hit tables in `wsim_core/tables/hit_tables.json`
- Range brackets: short (0-2), medium (3-5), long (6-10) hexes
- Separate tables for hull and rigging aim points
- D6-based hit resolution with range-specific outcomes
- Crew casualties table (separate D6 roll per hull hit)
- Gun damage table (only at short range)
- Easily adjustable for game balance without code changes

**Combat Resolution Logic:**
- Range calculation using hex distance
- Per-gun dice rolling with crew quality modifiers
- Hit lookup from data tables based on range bracket and aim point
- Secondary effects (crew casualties and gun damage) for hull hits
- Modifier clamping to valid die range (1-6)
- Complete audit trail with all dice rolls and modifiers

**Testing:**
- Comprehensive test suite with 25 tests covering:
  - Hit table loading and lookups (all range brackets and aim points)
  - Crew quality modifier calculation (full/75%/50%/<50% crew)
  - Broadside firing validation (loaded, struck, no guns)
  - Combat resolution at all ranges (short/medium/long)
  - Aim point differences (hull vs rigging)
  - Crew quality impact on results
  - Deterministic behavior with seeded RNG
  - Left and right broadside firing
  - No hits means no secondary effects
- All 262 project tests passing

**Quality:**
- Code formatted with ruff
- All linting checks pass
- Type checking passes with ty (strict mode)
- Proper integration with existing RNG, targeting, and arc systems
- Ready for damage application implementation

**Next Steps:**
Ready to implement damage application to ship tracks (wsim-xaz).

## 2026-01-19

### Closest-Target Rule Enforcement (wsim-g4g) - COMPLETED
Implemented comprehensive target selection logic enforcing the closest-target rule for combat:

**Core Features:**
- `get_ships_in_arc()`: Finds all ships (any part - bow or stern) within a broadside's firing arc
- `get_closest_enemy_in_arc()`: Returns the closest enemy ship in arc per closest-target rule
- `get_all_valid_targets()`: Returns all valid targets (handles equidistant cases)
- `is_valid_target()`: Validates if a specific ship can be legally targeted
- `get_targeting_info()`: Provides detailed targeting information for debugging/UI
- `TargetInfo` class: Encapsulates target ship, distance, and hex position

**Rule Implementation:**
- Only enemy ships (different side) are valid targets
- Struck ships cannot be targeted
- Only the CLOSEST enemy in arc can be targeted (strict WS&IM rule)
- Friendly ships in arc are ignored (no friendly fire)
- Handles equidistant enemies (all at minimum distance are valid)
- Ships outside firing arc cannot be targeted
- Distance calculated using proper hex geometry

**Testing:**
- Comprehensive test suite with 26 tests covering:
  - Ships in arc detection (bow, stern, friendly, range limits)
  - Closest enemy selection (single, multiple, filtering struck ships)
  - Valid target list generation (equidistant handling)
  - Target validation (all rules enforced)
  - Targeting info generation for UI/debugging
  - Complex scenarios (screening, multi-ship targeting)
- All 237 project tests passing
- Edge cases: equidistant targets, struck ships, friendly screening, out-of-arc

**Quality:**
- Code formatted with ruff
- All linting checks pass
- Type checking passes with ty (strict mode)
- Proper integration with existing arc calculation system
- Ready for combat system implementation

**Next Steps:**
Ready to implement data-driven hit tables and resolution (wsim-ool).

## 2026-01-19

### Broadside Arc Determination (wsim-9bf) - COMPLETED
Implemented broadside arc calculation system for combat targeting:

**Core Features:**
- `get_broadside_arc_hexes()`: Calculates all hexes within a ship's broadside firing arc
- `hex_distance()`: Computes distance between two hexes using cube coordinate conversion
- `is_hex_in_broadside_arc()`: Quick check if a specific hex is in arc (with range validation)
- Broadsides fire perpendicular to ship facing (L=port/west, R=starboard/east)
- Arc extends in a cone pattern up to configurable max_range (default 10 hexes)

**Implementation Details:**
- Perpendicular direction mapping for all 8 facings (N, NE, E, SE, S, SW, W, NW)
- Each broadside uses 3 primary directions to create ~90 degree firing arc
- Cone tracing algorithm widens arc at distance for realistic coverage
- Proper handling of hex geometry with odd-q vertical layout
- Bounds checking prevents negative coordinates during arc generation

**Testing:**
- Comprehensive test suite with 21 tests covering:
  - Hex distance calculations (same hex, adjacent, diagonal, symmetry)
  - Arc generation (excludes ship position, respects range, left vs right different)
  - Directional correctness (N facing fires L=west, R=east; E facing fires L=north, R=south)
  - All 8 facings produce valid arcs for both broadsides
  - In-arc and out-of-arc detection
  - Range enforcement
- All 211 project tests passing

**Quality:**
- Code formatted with ruff
- All linting checks pass
- Type checking passes with ty
- Ready for integration with closest-target rule and combat system

## 2026-01-19

### Backend Setup (wsim-n6i) - COMPLETED
Initialized the Python backend project with a complete development environment:

**Infrastructure:**
- Created project structure with `wsim_core` (pure rules engine) and `wsim_api` (FastAPI wrapper)
- Set up package directories: models, engine, tables, events, serialization, routers, deps
- Configured `uv` for package management with Python 3.12+

**Dependencies:**
- FastAPI 0.115+ with uvicorn for ASGI server
- Pydantic v2 for data validation and models
- pytest with coverage, hypothesis, and httpx for testing
- ruff for formatting and linting (line-length 100)
- ty for strict type checking

**Quality Assurance:**
- All code formatted with ruff (12 files checked)
- All linting checks pass
- Type checking passes with ty (strict mode)
- Test suite runs successfully (2/2 tests passing)

**API Foundation:**
- Basic FastAPI application with health endpoint
- CORS configured for local development (ports 3000 and 5173)
- OpenAPI documentation available at /docs
- Test client setup with httpx

**Next Steps:**
Ready to implement core Pydantic models (wsim-vbx) for game state representation.

### Collision Detection and Resolution (wsim-n42) - COMPLETED
Implemented comprehensive collision detection and resolution system for simultaneous ship movement:

**Core Features:**
- Hex occupancy tracking: `detect_hex_occupancy()` builds map of which ships occupy which hexes
- Collision detection: `detect_collisions()` compares before/after positions to find collisions
- Smart resolution logic with proper priority rules:
  - Stationary ships have priority over moving ships
  - Random die roll (d6) when multiple ships move into same hex
  - Displaced ships moved back to previous positions
- Voluntary movement truncation for all ships involved in collisions
- Full event logging for audit trail and debugging

**Implementation:**
- Created `wsim_core/engine/collision.py` module (~290 lines)
- Integrates with existing RNG system for deterministic testing
- Uses Pydantic models for type safety (CollisionResolution, CollisionResult)
- Emits EventLogEntry objects for each collision with detailed metadata

**Testing:**
- Comprehensive test suite with 13 collision-specific tests
- Tests cover: hex occupancy, detection, resolution priorities, determinism
- All 152 tests pass (including existing tests)
- Test scenarios: bow collisions, stern collisions, multi-ship collisions
- Validates deterministic behavior with seeded RNG

**Quality Checks:**
- ruff formatting and linting: clean
- ty type checking (strict mode): clean
- Ready for integration into movement execution engine

**Next Steps:**
Ready to implement fouling system (wsim-8gn) which builds on collision detection.

### Drift Logic (wsim-znh) - COMPLETED
Implemented comprehensive drift system for ships that fail to advance their bow hex:

**Core Features:**
- Drift tracking: Ships track consecutive turns without bow advancement via `turns_without_bow_advance` counter
- Drift trigger: Ships drift 1 hex downwind after 2 turns without bow advance
- Downwind calculation: `get_downwind_direction()` determines drift direction (opposite of wind)
- Bounds validation: Prevents drift that would move ships off the map edge
- Position updates: Both bow and stern hexes move consistently in drift direction
- Counter management: Drift counter resets after drift application or successful bow advancement

**Implementation:**
- Created `wsim_core/engine/drift.py` module (~230 lines)
- Key functions:
  - `get_downwind_direction()`: Calculates drift direction from wind direction
  - `update_drift_tracking()`: Updates ship drift counters based on movement results
  - `apply_drift()`: Applies drift to eligible ships with bounds checking
  - `check_and_apply_drift()`: Convenience function combining tracking and drift
- Manual hex coordinate calculation to validate bounds before HexCoord creation
- Uses GamePhase enum for proper event type safety
- Emits EventLogEntry objects for both "drift" and "drift_blocked" events

**Testing:**
- Comprehensive test suite with 23 drift-specific tests
- Tests cover:
  - Downwind direction calculation for all 8 compass points
  - Drift tracking increments and resets
  - Drift application at 2-turn threshold
  - Bounds checking (all map edges: north, south, east, west)
  - Multiple ships drifting simultaneously
  - Event metadata validation and completeness
  - Integration scenarios with sequential turns
  - Preservation of other ship attributes during drift
- All 190 tests pass (23 new drift tests + 167 existing)

**Quality Checks:**
- ruff formatting and linting: clean
- ty type checking (strict mode): clean
- Ready for integration into movement execution engine

**Next Steps:**
Ready to implement broadside arc determination (wsim-9bf) for combat system.

## 2026-01-19 - Damage Application System (wsim-xaz)

Implemented the complete damage application system for the combat engine:

**Core Features:**
- Hull damage application with automatic struck detection when hull reaches 0
- Rigging damage application (no struck condition)
- Crew casualty distribution: marines first, then crew
- Automatic struck when all crew+marines lost
- Gun damage distribution: target-specific broadside or evenly distributed
- Comprehensive damage tracking with before/after state
- Event log generation for all damage applications

**Key Components:**
- `DamageApplication` model: Pydantic model tracking all damage changes
- `apply_hit_result_to_ship()`: Main function applying HitResult to Ship
- `_apply_gun_damage()`: Distributes gun losses across broadsides
- `_check_struck_condition()`: Determines when ships strike
- `create_damage_event()`: Creates detailed event log entries

**Test Coverage:**
21 new tests covering:
- Basic and edge case damage scenarios
- Negative value prevention
- Struck condition detection
- Gun damage distribution algorithms
- Sequential damage application
- Event creation with full metadata

All 283 tests passing. Code quality verified with ruff and ty.

**Impact:**
This completes the core combat damage loop. Ships can now take damage from broadsides and strike when critically damaged. Next priorities: reload system and event logging infrastructure.

## 2026-01-19 - Frontend Project Setup (wsim-l9m)

Initialized the React frontend with Vite and TypeScript for the WSIM web UI:

**Core Setup:**
- Created frontend project using Vite with React + TypeScript template
- Established project structure: src/api, src/components, src/pages, src/state, src/types
- Installed React Router for client-side routing
- Configured build pipeline and verified successful compilation

**API Integration:**
- Created TypeScript type definitions mirroring backend Pydantic models
  - Game, Ship, Scenario, and all supporting types
  - Request/response types for all planned API endpoints
- Implemented API client (src/api/client.ts) with typed fetch wrapper
  - Configured for localhost:8000 FastAPI backend
  - Environment variable support for API base URL
  - Error handling with custom ApiError class
  - All planned endpoints stubbed: scenarios, games, orders, combat, etc.

**Routing Foundation:**
- Basic React Router setup with two routes:
  - HomePage (/) - placeholder for scenario selection
  - GamePage (/game/:gameId) - placeholder for game board and controls
- Clean App.tsx with routing structure

**Quality:**
- TypeScript compilation succeeds with no errors
- Build process verified (npm run build)
- No backend changes, so ruff/ty checks not needed

**Next Steps:**
Ready to implement FastAPI endpoints (wsim-d8i) or start building frontend UI components (wsim-uva, wsim-787, wsim-8ly, wsim-88j). The frontend foundation is complete and ready for feature development.

## 2026-01-19 - Orders Submission and Ready Gate API (wsim-a7g)

Implemented the API endpoints for the Planning phase to enable secret movement plotting and ready gate mechanics:

### Endpoints Implemented:
- **POST /games/{id}/turns/{turn}/orders**: Submit movement orders for a player's ships
  - Accepts side (P1/P2) and list of ShipOrders (ship_id + movement_string)
  - Validates turn number matches current game turn
  - Ensures phase is PLANNING
  - Validates all orders are for ships belonging to the player
  - Requires orders for ALL player ships (no partial submissions)
  - Stores TurnOrders in game state (p1_orders or p2_orders)
  - Returns updated game state and success confirmation

- **POST /games/{id}/turns/{turn}/ready**: Mark a player as ready to proceed
  - Validates that player has already submitted orders
  - Validates turn number and phase
  - Returns ready status and whether BOTH players are ready
  - Enables ready gate: orders revealed when both_ready is true

### Validation Logic:
- Turn number must match game.turn_number
- Can only submit/ready in PLANNING phase
- Ship IDs must belong to the player's side
- All player's ships must have orders before marking ready
- Cannot mark ready without submitted orders

### Quality Checks:
- ✅ All 337 tests passing
- ✅ Ruff formatting and linting (all checks passed)
- ✅ Ty type checking (all checks passed)

### Integration:
- Uses existing Game and TurnOrders models
- Works with in-memory GameStore
- Full FastAPI request/response validation with Pydantic
- CORS enabled for frontend development

This implementation completes the planning phase API foundation, enabling the frontend to implement secret order entry and ready gate UI workflows.

---

## 2026-01-19 17:16 - Implemented Reload and Turn Advance API Endpoints (wsim-739)

### Summary:
Completed the final two endpoints needed for the MVP turn loop: reload and turn advance. These endpoints complete the turn cycle allowing games to progress through Planning → Movement → Combat → Reload → Advance (back to Planning).

### What Was Built:

#### 1. POST /games/{id}/turns/{turn}/resolve/reload
**Purpose:** Reload all fired broadsides during the reload phase

**Implementation:**
- Validates game exists, turn number matches, and phase is COMBAT
- Uses existing `reload_all_ships()` from wsim_core.engine.reload
- Reloads all empty broadsides on non-struck ships with roundshot
- Creates detailed event log entries for each ship's reload operations
- Transitions game phase to RELOAD
- Returns updated game state and list of reload events

**Key Logic:**
- Skips struck ships (they cannot reload)
- Only reloads empty broadsides (already loaded broadsides unchanged)
- MVP only uses roundshot ammunition type
- Event log captures which broadsides were reloaded per ship

#### 2. POST /games/{id}/turns/{turn}/advance
**Purpose:** Advance to the next turn after reload completes

**Implementation:**
- Validates game exists, turn number matches, and phase is RELOAD
- Increments turn_number by 1
- Clears both p1_orders and p2_orders (ready for next turn)
- Transitions game phase back to PLANNING
- Returns updated game state ready for next turn's order entry

**Phase Validation:**
- Can only advance from RELOAD phase (ensures turn is complete)
- After advance, game is in PLANNING phase for new turn
- Orders are cleared to prevent reuse from previous turn

### Testing:
- All 348 existing tests continue to pass
- Ruff formatting and linting: all checks passed
- Ty type checking: all checks passed
- No new test files added (existing tests cover underlying engine functions)

### Technical Details:

**Reload Endpoint:**
```python
- Request: POST /games/{game_id}/turns/{turn}/resolve/reload
- Response: { state: Game, events: EventLogEntry[] }
- Phase transition: COMBAT → RELOAD
- Engine function: reload_all_ships(ships, turn_number)
- Event creation: create_reload_event(result, turn, ship_name)
```

**Advance Turn Endpoint:**
```python
- Request: POST /games/{game_id}/turns/{turn}/advance
- Response: { state: Game }
- Phase transition: RELOAD → PLANNING
- State changes: turn_number++, p1_orders=null, p2_orders=null
```

### Integration:
- Uses existing reload engine (wsim_core.engine.reload)
- Uses existing Game and EventLogEntry models
- Works with in-memory GameStore
- Full FastAPI request/response validation with Pydantic
- Proper HTTP error codes for validation failures

### What This Enables:
This completes the MVP turn loop API. A complete turn cycle is now:
1. Planning Phase: Submit orders (POST /turns/{turn}/orders) + Mark ready (POST /turns/{turn}/ready)
2. Movement Phase: Resolve movement (POST /turns/{turn}/resolve/movement)
3. Combat Phase: Fire broadsides (POST /turns/{turn}/combat/fire) - can fire multiple times
4. Reload Phase: Reload broadsides (POST /turns/{turn}/resolve/reload)
5. Advance: Move to next turn (POST /turns/{turn}/advance)
6. Loop back to Planning Phase with turn_number incremented

The frontend can now implement the full game loop including multi-turn gameplay with proper state management and event logging.

## 2026-01-19 - Scenario Selection Screen (wsim-88j)

Implemented the scenario selection screen to allow users to create new games:

### Frontend Implementation:
**HomePage Component:**
- Fetches available scenarios from API on mount
- Displays scenario list with name, description, and "Start Game" button
- Shows loading state while fetching scenarios
- Error handling with user-friendly error messages
- Disabled state during game creation to prevent double-clicks
- Navigates to game page after successful game creation

**Features:**
- Clean, simple UI with inline styles
- Responsive layout (centered with max-width)
- Loading indicator while fetching scenarios
- Error display with visual styling (red background)
- Individual loading state per scenario button

### API Client Updates:
Fixed several API client issues to match backend implementation:
- Updated scenarios endpoint from `/scenarios` to `/games/scenarios`
- Changed response type from `Scenario[]` to `ScenarioInfo[]` (matches backend's ScenarioInfo model)
- Added `ScenarioInfo` type definition (id, name, description only)
- Fixed `SubmitOrdersRequest` field from `player` to `side` (matches backend)
- Fixed `MarkReadyRequest` field from `player` to `side`
- Added `AdvanceTurnResponse` type
- Updated `SubmitOrdersResponse` to include `orders_submitted` boolean
- Updated `MarkReadyResponse` to include `ready` and `both_ready` booleans
- Fixed `getGame()` return type from `{ state: Game }` to `Game`
- Fixed `advanceTurn()` return type to use `AdvanceTurnResponse`

### Quality:
- All 348 backend tests passing
- Ruff formatting and linting: all checks passed
- Ty type checking: all checks passed
- Frontend builds successfully with no TypeScript errors

### What This Enables:
Users can now:
1. View all available scenarios on the home page
2. Read scenario descriptions to choose the right one
3. Click "Start Game" to create a new game instance
4. Be automatically navigated to the game page

This completes the first user-facing screen of the MVP. Next priorities are implementing the game board hex grid (wsim-uva) and ship rendering (wsim-787).

## 2026-01-19 - Hex Grid Board Rendering (wsim-uva)

Implemented SVG-based hex grid rendering component for the game board:

### Frontend Implementation:

**Hex Coordinate System (src/types/hex.ts):**
- `HexCoordinate` interface: col/row coordinate representation
- `HexLayout` interface: hex size, origin, and orientation config
- `hexToPixel()`: Converts hex coordinates to pixel positions using offset coordinates (odd-r layout)
- `getHexCorners()`: Calculates six corner points for flat-top hexagon SVG polygons
- `cornersToPoints()`: Formats corner array as SVG points string

**HexGrid Component (src/components/HexGrid.tsx):**
- SVG-based rendering for scalability and performance
- Responsive sizing using viewBox (adapts to container)
- Configurable grid dimensions (width x height) and hex size
- Interactive features:
  - Click handling per hex
  - Hover effects with semi-transparent highlight
  - Coordinate labels displayed on each hex
- Dark blue naval theme styling
- Memoized hex calculations for performance
- Cursor changes to pointer when clickable

**GamePage Integration:**
- Imported HexGrid component into GamePage
- Added state management for selected hex
- Default dimensions set to Frigate Duel scenario (25x20)
- Selected hex coordinates displayed in header
- Flexbox layout with proper scrolling

### Technical Details:
- Uses flat-top hexagon orientation
- Offset coordinate system (odd-r layout) for simpler math
- SVG viewBox ensures grid scales responsively
- All hexes display [col,row] coordinates for debugging
- Hover effects only active when onHexClick handler provided

### Quality:
- TypeScript compilation passes with no errors
- ESLint passes with no issues
- Proper type-only imports for verbatimModuleSyntax compliance
- Frontend builds successfully

### What This Enables:
The game board foundation is now in place. Users can:
1. See a properly rendered hex grid matching scenario dimensions
2. Click on hexes and see coordinates (foundation for ship placement/selection)
3. View the grid responsively in any browser window size

Next priorities: ship rendering as 2-hex pieces (wsim-787) and ship log panel UI (wsim-8ly).

---

## 2026-01-19: Event Log Display Panel Implementation (wsim-d0w)

### Implemented Features:
Completed a comprehensive event log display panel that provides full transparency into game actions and outcomes.

**EventLog Component (frontend/src/components/EventLog.tsx):**
- Chronological display of all game events grouped by turn
- Clear phase badges with color coding:
  - Planning: Blue (#4a90e2)
  - Movement: Green (#50c878)
  - Combat: Red (#e74c3c)
  - Reload: Orange (#f39c12)
- Event type badges for quick identification
- Detailed dice roll display with individual rolls and totals (e.g., "2d6: [3, 5] = 8")
- Modifier display showing all applied modifiers
- Auto-scroll functionality to latest events
- Dual filtering system:
  - Phase filter (all/planning/movement/combat/reload)
  - Event type filter (dynamically populated from actual event types)
- Current turn highlighting for easy navigation
- Event count badge showing filtered results
- Scrollable container with proper overflow handling

**Type System Updates:**
- Updated EventLogEntry interface to match backend Pydantic model
- Added DiceRoll interface with num_dice, die_type, rolls array, and total
- Changed event_type field name from 'type' to match backend
- Added optional metadata field for extensibility
- Fixed CombatPanel to use new dice_roll structure

**GamePage Integration:**
- Added EventLog as bottom panel in 3-panel layout
- 280px fixed height for optimal visibility without overwhelming UI
- Integrated with existing game state and event_log data
- Passes currentTurn prop for context highlighting
- Maintains responsive layout with proper flex behavior

### Technical Details:
- Component uses React refs for auto-scroll behavior
- Groups events by turn using reduce for efficient rendering
- Color-coded phase badges match game phase colors throughout UI
- Monospace font for dice and modifier display (better readability)
- Smooth scroll behavior on new events
- Proper TypeScript typing throughout
- Zero compilation errors or warnings

### Quality Assurance:
- All backend tests pass (348 tests)
- Backend ruff formatting check passes
- Backend ruff linting passes with "All checks passed!"
- Backend ty type checking passes
- Frontend TypeScript compilation succeeds
- Frontend builds successfully with Vite

### What This Enables:
Players can now:
1. See complete audit trail of all game actions
2. Filter events by phase or type for debugging
3. Review dice rolls and modifiers for transparency
4. Track game progress turn-by-turn
5. Quickly identify current turn events
6. Debug rule application and outcomes

The event log is a critical feature for MVP as it provides transparency, aids debugging during development, and builds player trust in the rules engine.

